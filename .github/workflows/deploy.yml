name: Build and Deploy to EKS

# ============================================================
# TRIGGER: When does this pipeline run?
# ============================================================
# This pipeline runs when:
# - Code is pushed to the 'main' branch
# - AND files in the 'app/' directory changed
# This prevents unnecessary builds when only docs or terraform change
on:
  push:
    branches:
      - main
    paths:
      - 'app/**'

# ============================================================
# GLOBAL ENVIRONMENT VARIABLES
# ============================================================
# These are available to ALL jobs and steps in this workflow
# AWS_REGION is constant across environments, so we define it here
env:
  AWS_REGION: us-east-1

# ============================================================
# JOBS: The actual work to be done
# ============================================================
jobs:
  deploy:
    name: Build and Deploy
    
    # Runner: Use GitHub's hosted Ubuntu machine
    # This is a fresh VM that runs our pipeline
    runs-on: ubuntu-latest

    # ========================================================
    # ENVIRONMENT: Links to GitHub Environment settings
    # ========================================================
    # This pulls variables and secrets from the 'dev' environment
    # Variables are accessed via: ${{ vars.VARIABLE_NAME }}
    # Secrets are accessed via: ${{ secrets.SECRET_NAME }}
    environment: dev
    
    steps:
      # ======================================================
      # STEP 1: CHECKOUT CODE
      # ======================================================
      # Downloads your repository code to the runner
      # Without this, the runner has no access to your files
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Checkov Kubernetes Manifest Scan
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: k8s-manifests/
          quiet: true
          soft_fail: true
          framework: kubernetes

      # ======================================================
      # STEP 2: CONFIGURE AWS CREDENTIALS
      # ======================================================
      # Sets up AWS CLI with your IAM credentials
      # This allows subsequent steps to interact with AWS services
      # Secrets come from GitHub Environment secrets
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ======================================================
      # STEP 3: LOGIN TO AMAZON ECR
      # ======================================================
      # Authenticates Docker to your private ECR registry
      # This is like running: aws ecr get-login-password | docker login
      # The 'id: login-ecr' lets us reference outputs in later steps
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # ======================================================
      # STEP 4: BUILD DOCKER IMAGE
      # ======================================================
      # Builds the Docker image (but doesn't push yet - scan first!)
      - name: Build Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build for amd64 architecture (EKS runs on Intel/AMD, not ARM)
          docker build \
            --platform linux/amd64 \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            ./app

          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # ======================================================
      # STEP 5: TRIVY IMAGE VULNERABILITY SCAN
      # ======================================================
      # Scans the built image for known vulnerabilities (CVEs)
      - name: Trivy Image Vulnerability Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ steps.login-ecr.outputs.registry }}/${{ vars.ECR_REPOSITORY }}:${{ github.sha }}'
          format: 'table'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'

      # ======================================================
      # STEP 6: PUSH IMAGE TO ECR
      # ======================================================
      # Now that the image passed security scan, push to ECR
      - name: Push image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      # ======================================================
      # STEP 7: UPDATE KUBECONFIG
      # ======================================================
      # Configures kubectl to communicate with your EKS cluster
      # This is like running: aws eks update-kubeconfig --name <cluster>
      # After this step, kubectl commands will target your EKS cluster
      - name: Update kubeconfig
        env:
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name $EKS_CLUSTER_NAME

      # ======================================================
      # STEP 8: DEPLOY TO EKS
      # ======================================================
      # Updates the deployment with the new image
      # 
      # kubectl set image: Updates container image without editing YAML
      # kubectl rollout status: Waits for deployment to complete
      # 
      # If deployment fails, the step fails and pipeline stops
      - name: Deploy to EKS
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Update the deployment to use the new image
          # Format: kubectl set image deployment/<name> <container>=<image>
          kubectl set image deployment/eks-sample-app \
            eks-sample-app=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          # Wait for the rollout to complete (max 5 minutes)
          # This ensures the new pods are running before marking success
          kubectl rollout status deployment/eks-sample-app --timeout=300s